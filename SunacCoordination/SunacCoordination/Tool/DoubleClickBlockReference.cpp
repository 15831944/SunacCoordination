// DoubleClickCircle.cpp: implementation of the CDoubleClickCircle class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "DoubleClickBlockReference.h"
#include <dbents.h>
#include <actrans.h>
#include "../Common/ComFun_Sunac.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDoubleClickBlockReference::CDoubleClickBlockReference()
{

}

CDoubleClickBlockReference::~CDoubleClickBlockReference()
{

}

void CDoubleClickBlockReference::startEdit( AcDbEntity *pEnt, AcGePoint3d pt )
{
	// 获得当前文档
	AcApDocument *pDoc = acDocManager->curDocument();
	
	// 将AcDbEntity指针转换为AcDbLine指针
	if (pEnt->isKindOf(AcDbBlockReference::desc()))
	{
		AcDbBlockReference *pBlockReference = AcDbBlockReference::cast(pEnt);

		// 锁定文档
		acDocManager->lockDocument(pDoc);
		
		// 将实体的打开状态升级为可写状态
		pBlockReference->upgradeOpen();
		
		bool isWindow = TY_IsWindow(pBlockReference->objectId());

		pBlockReference->close();
		
		// 解锁文档
		acDocManager->unlockDocument(pDoc);
		
		// 清理PickFirst选择集中的内容
		//acedSSSetFirst(NULL, NULL);
		
		// 更新图形的显示
		pBlockReference->draw();		// 为什么能在关闭之后还能使用它？我也不太清楚
		actrTransactionManager->flushGraphics();
		acedUpdateDisplay();		
	}
	else
	{
		acutPrintf(L"\n无效的AcDbBlockReference对象...");
		pEnt->close();
		return;
	}
}

void CDoubleClickBlockReference::finishEdit( void )
{
	// 此处不使用
}